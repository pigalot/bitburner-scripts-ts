import { NS, Player } from "/../types/NetscriptDefinitions";

import { Deamon } from "/deamons/Deamon.js";
import { getGrowTime, getHackTime, getWeakenTime, growAnalyzeHackAmount, growAnalyzeSecurity, hackAnalyze, hackAnalyzeChance, hackAnalyzeSecurity, weakenAnalyze } from "gameFunctions.js";
import { ServerData } from "/models/ServerData.js";
import { Batch } from "/deamons/targeter/data.js";

export async function main(ns: NS) {
    ns.disableLog("ALL");
    ns.clearLog();

    const deamon = new TargeterDeamon(ns);
    await deamon.run(false);
}

/*
    this is a ts implimentation of Draks hacking script
    https://github.com/zeddrak/bitburner-scripts
    https://discord.com/channels/415207508303544321/923707505698283560/927176443002228796
*/

class TargeterDeamon extends Deamon {
    private readonly minBufferTime = 30;
    private readonly maxProcesses = 8000;
    private readonly threadBufferMultiplier = 1.10;
    private readonly MaxHackAmount = 0.95;
    private readonly maxRamToUse = 0.90;

    constructor(ns: NS) {
        super(ns);

    }

    public async run(detail: boolean) {
        const batches: Batch[] = [];
        const player = this.ns.getPlayer();
        const servers = this.spiderData.routedServers.filter(s => s.requiredHack <= player.hacking && s.money > 0 && (s.name === this.stonksData.stonksServer && this.stonksData.isStonks));
        console.log(servers);
        const maxCost = this.resourceManagerData.totalRam * this.maxRamToUse;
        for (const target of servers) {
			await this.ns.sleep(1);

            let best = this.estimateBestScore(target, 1, player);
            let ret = best;
            while (ret.ramCost / maxCost > 1.0) { //hN 1 profile to expensive, lengrhen cL to reduce cost
                await this.ns.sleep(0);
                ret = this.estimateBestScore(target, 1, player, Math.ceil(ret.calculatedBufferTime * ret.ramCost / maxCost));
            }
            if (this.stonksData.isStonks) {
                batches.push(best);
                continue; // only need one hack for stonks
            }
			let hN = 2;

			do {
				await this.ns.sleep(0);
				//check for a better target
				ret = this.estimateBestScore(target, hN, player);
                
                if (ret.score > 0 && maxCost - ret.ramCost > 0 && (hN == 1 || this.MaxHackAmount - ret.amountHacked > 0) && ret.moneyPerMs - best.moneyPerMs > 0) {
					best = ret;
				} //new best target
				if (detail) { hN++; } else { //high detail pass every 10th
					if (ret.amountHacked < 0.01) { hN += hN < 10 ? 1 : hN < 100 ? 10 : Math.ceil(0.0001 / ret.hackAmount); } //step by 0.01%
					else { hN += Math.ceil(0.02 / ret.hackAmount); } //step by 0.2%
				}
			} while ((ret.score > 0) && (maxCost - ret.ramCost > 0) && (this.MaxHackAmount - ret.amountHacked > 0))
            batches.push(best);
		}
        this.targeterData.targets = batches.sort((a, b) => (b.moneyPerMs - a.moneyPerMs > 0) ? 1 : (b.moneyPerMs == a.moneyPerMs) ? ((b.ramCost - a.ramCost > 0) ? -1 : 1) : -1);
        this.targeterData.initialised = true;
    }

    /** 
     * @param hackThreads Must be an interger > 0
     */
    private estimateBestScore(target: ServerData, hackThreads: number, player: Player, bufferTime = this.minBufferTime, cores = 1): Batch {
        //const ret = { score: 0, tar: tar, hN: hN };
        //if (tardat == {}) try { tardat = asd.servers.dat[asd.servers.dat.indexof(tar) + 1]; } catch { return ret; }
        //if (tardat == {}) { return ret; } //can't get dat, abort

        const hackScriptSize = 1.70;
        const growScriptSize = 1.75;
        const weakenScriptSize = 1.75;

        const hackAmount = hackAnalyze(target.server, player, this.gameInfoData.bitNodeMultipliers?.ScriptHackMoney ?? 1); //PER THREAD
        const amountHacked = hackAmount * hackThreads; //amt hacked (as portion of currentMoney) -- if Hacking/Growing properly, then of MaxMoney
        const hackSecurity = hackAnalyzeSecurity(hackThreads); //amount of security generated by each hack
        const postHackSecurity = Math.min(100, target.security + hackSecurity); //security level after hack hits (max 100) //

        let growThreads = Math.max(1, Math.ceil(this.threadBufferMultiplier * growAnalyzeHackAmount(target.server, player, amountHacked, this.gameInfoData.bitNodeMultipliers?.ServerGrowthRate ?? 1, postHackSecurity))); //number of Grow threads needed to offset each hack
        if (this.stonksData.isStonks) growThreads = 1;
        const growSecurity = growAnalyzeSecurity(growThreads); //amount of security generated by the Grow threads
        const postGrowSec = Math.min(100, target.security + growSecurity);

        const hackChance = 0.5 * (hackAnalyzeChance(target.server, player) + hackAnalyzeChance(target.server, player, postGrowSec)); // chance for a successful hack (at minSec)

        const maxSecurityToWeaken = 100 - target.security; // Caps weaken threads (max security is 100, so max security needing weaken is 100-minSec)

        const weakenAmountOffset = weakenAnalyze(1, cores); //amount of security offset by each weaken thread
        const weakenThreads = Math.max(1, Math.ceil(Math.min(maxSecurityToWeaken, (2 * this.threadBufferMultiplier * (hackSecurity + growSecurity))) / weakenAmountOffset)); // number of weaken threads needed to offset each HackGrow pair

        const hackTime = getHackTime(target.server, player, target.security); // time required to finish a minSec Hack //
        const growTime = getGrowTime(target.server, player, target.security); // time required to finish a minSec Grow //
        const weakenTime = getWeakenTime(target.server, player, target.security); // time required to finish a minSec Weaken //

        const calculatedBufferTime = Math.ceil(Math.max(bufferTime, (hackTime * 8.2 / 3.0 / this.maxProcesses))); // Buffer Time between attacks
        const cycleLength = 3.0 * calculatedBufferTime; // length of a cycle (hgw)

        const hackProcesses = Math.ceil(hackTime / cycleLength); //number of Hack processes continuously running
        const growProcesses = Math.ceil(1.0 * growTime / cycleLength); //number of Grow processes continuously running
        const weakenProcesses = Math.ceil(1.0 * weakenTime / cycleLength); //number of Weaken processes continuously running
        const totalProcesses = hackProcesses + growProcesses + weakenProcesses; //total number of processes to run this profile
        
        const moneyPerMs = amountHacked * target.money * hackChance / cycleLength; // $ per millisecond
        const ramCost = hackScriptSize * hackThreads * hackProcesses + 1 *
            growScriptSize * growThreads * growProcesses + 1 *
            weakenScriptSize * weakenThreads * weakenProcesses; //cost in GB
        const score = moneyPerMs / ramCost; // $ / ms / GB
        return {
            serverData: target, // tar

            hackAmount, // hA
            amountHacked, // amt

            hackThreads, // hN
            growThreads, // gN
            weakenThreads, // wN

            hackProcesses, // hP
            growProcesses, // gP
            weakenProcesses, // wP
            totalProcesses, // totP

            hackTime, //hT

            calculatedBufferTime, // bT
            cycleLength, // cL

            moneyPerMs, // value
            ramCost, // cost
            score, // score
        };
    }

}